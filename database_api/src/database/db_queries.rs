use actix_web::{web::Data, HttpRequest, HttpResponse};

use crate::{
    app_state::AppState,
    database::{
        db_setup::{establish_db_connection, spawn_connection},
        query_constructor::query_constructor::{construct_operation, DbOperation},
    },
    models::pure::chat::message::Message,
};

pub async fn insert_message(message: Message, _req: HttpRequest) -> HttpResponse {
    //INSERT INTO {MESSAGES(all rows)} VALUES ({all values});
    let table: String = String::from("messages(id, issuer, message)");
    let mut items: Vec<String> = Vec::with_capacity(3);
    items.push("".to_string()); //ID: Should be autogenerated
    items.push("".to_string()); //Issuer: TODO: Think wtf shall I do with the relation
    items.push(message.message); //Message: Got from the user

    let query: String = construct_operation(DbOperation::Insert, Some(table), Some(items), None);

    let db_connection = establish_db_connection().await;
    spawn_connection(db_connection.1);

    let rows = db_connection.0.simple_query(&query).await?;
    let rows_affected = rows[0].get(0);
    Ok(HttpResponse::Created().body(format!("Rows affected: {}", rows_affected)));

    // match db_connection.0.prepare(query.as_str()).await {
    //     Ok(_) => HttpResponse::Created().body("Message inserted."),
    //     Err(err) => HttpResponse::BadRequest().body(format!(
    //         "Unable to prepare database operation! Err: {}",
    //         err
    //     )),
    // }
}

// pub async fn query_chat(chat: Chat) -> Result<HttpResponse, Error> {
//     todo!("Implement query_from_db")
// }
